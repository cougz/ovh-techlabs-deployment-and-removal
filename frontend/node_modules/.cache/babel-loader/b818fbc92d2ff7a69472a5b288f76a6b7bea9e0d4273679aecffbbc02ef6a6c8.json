{"ast":null,"code":"import{useEffect,useRef,useState,useCallback}from'react';import{useQueryClient}from'react-query';export const useWebSocket=_ref=>{let{workshopId,onMessage,onStatusUpdate,onDeploymentLog,onDeploymentProgress}=_ref;const[isConnected,setIsConnected]=useState(false);const[connectionError,setConnectionError]=useState(null);const wsRef=useRef(null);const reconnectTimeoutRef=useRef(null);const pingIntervalRef=useRef(null);const reconnectAttemptsRef=useRef(0);const queryClient=useQueryClient();const connect=useCallback(()=>{var _wsRef$current;if(((_wsRef$current=wsRef.current)===null||_wsRef$current===void 0?void 0:_wsRef$current.readyState)===WebSocket.OPEN){return;}const token=localStorage.getItem('token');const wsProtocol=window.location.protocol==='https:'?'wss':'ws';const wsHost=window.location.host;const wsUrl=`${wsProtocol}://${wsHost}/ws/${workshopId}${token?`?token=${token}`:''}`;console.log('Connecting to WebSocket:',wsUrl);try{const ws=new WebSocket(wsUrl);wsRef.current=ws;ws.onopen=()=>{console.log('WebSocket connected');setIsConnected(true);setConnectionError(null);reconnectAttemptsRef.current=0;// Start ping interval\npingIntervalRef.current=setInterval(()=>{if(ws.readyState===WebSocket.OPEN){ws.send(JSON.stringify({type:'ping'}));}},30000);// Ping every 30 seconds\n};ws.onmessage=event=>{try{const message=JSON.parse(event.data);// Handle different message types\nswitch(message.type){case'connection':console.log('WebSocket connection confirmed');break;case'status_update':if(message.entity_type&&message.entity_id&&message.status){// Invalidate React Query cache to trigger re-fetch\nqueryClient.invalidateQueries(['attendees',workshopId]);queryClient.invalidateQueries(['workshop',workshopId]);// Call callback\nonStatusUpdate===null||onStatusUpdate===void 0?void 0:onStatusUpdate(message.entity_type,message.entity_id,message.status,message.details);}break;case'deployment_log':if(message.attendee_id&&message.log_entry){onDeploymentLog===null||onDeploymentLog===void 0?void 0:onDeploymentLog(message.attendee_id,message.log_entry);}break;case'deployment_progress':if(message.attendee_id&&message.progress!==undefined&&message.current_step){onDeploymentProgress===null||onDeploymentProgress===void 0?void 0:onDeploymentProgress(message.attendee_id,message.progress,message.current_step);}break;case'pong':// Heartbeat response\nbreak;}// Call general message handler\nonMessage===null||onMessage===void 0?void 0:onMessage(message);}catch(error){console.error('Error parsing WebSocket message:',error);}};ws.onerror=error=>{console.error('WebSocket error:',error);setConnectionError('WebSocket connection error');};ws.onclose=event=>{console.log('WebSocket disconnected:',event.code,event.reason);setIsConnected(false);wsRef.current=null;// Clear ping interval\nif(pingIntervalRef.current){clearInterval(pingIntervalRef.current);pingIntervalRef.current=null;}// Attempt reconnection with exponential backoff\nif(reconnectAttemptsRef.current<5){const delay=Math.min(1000*Math.pow(2,reconnectAttemptsRef.current),30000);reconnectAttemptsRef.current++;console.log(`Reconnecting in ${delay}ms (attempt ${reconnectAttemptsRef.current})`);reconnectTimeoutRef.current=setTimeout(()=>{connect();},delay);}else{setConnectionError('Failed to connect after multiple attempts');}};}catch(error){console.error('Error creating WebSocket:',error);setConnectionError('Failed to create WebSocket connection');}},[workshopId,queryClient,onMessage,onStatusUpdate,onDeploymentLog,onDeploymentProgress]);const disconnect=useCallback(()=>{if(reconnectTimeoutRef.current){clearTimeout(reconnectTimeoutRef.current);reconnectTimeoutRef.current=null;}if(pingIntervalRef.current){clearInterval(pingIntervalRef.current);pingIntervalRef.current=null;}if(wsRef.current){wsRef.current.close();wsRef.current=null;}setIsConnected(false);setConnectionError(null);reconnectAttemptsRef.current=0;},[]);const sendMessage=useCallback(message=>{var _wsRef$current2;if(((_wsRef$current2=wsRef.current)===null||_wsRef$current2===void 0?void 0:_wsRef$current2.readyState)===WebSocket.OPEN){wsRef.current.send(JSON.stringify(message));return true;}return false;},[]);// Connect on mount and disconnect on unmount\nuseEffect(()=>{connect();return()=>{disconnect();};},[connect,disconnect]);return{isConnected,connectionError,sendMessage,reconnect:connect,disconnect};};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}